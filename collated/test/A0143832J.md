# A0143832J
###### /java/seedu/address/commons/util/CollectionUtilTest.java
``` java
    @Test
    public void checkMutualOrContains() throws IllegalValueException {
        UniqueTagList list1 = new UniqueTagList();
        UniqueTagList list2 = new UniqueTagList();
        list1.add(new Tag("friends"));
        list2.add(new Tag("frie"));
        assertMutualOrContain(list1.toSet(), list2.toSet());

        //disjoint
        list2.add(new Tag("friend"));
        assertMutualOrContain(list1.toSet(), list2.toSet());

        //return false
        UniqueTagList list3 = new UniqueTagList();
        list3.add(new Tag("cs2103"));
        assertNotMutualOrContain(list1.toSet(), list3.toSet());


    }
```
###### /java/seedu/address/commons/util/LanguageUtilTest.java
``` java
package seedu.address.commons.util;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class LanguageUtilTest {
    @Test
    public void getClosestCommand() throws Exception {
        //for find
        assertEquals("find", getCommand("fnid"));
        assertEquals("find", getCommand("fin"));

        //for add
        assertEquals("add", getCommand("ad"));
        assertEquals("add", getCommand("dad"));

        //for delete
        assertEquals("delete", getCommand("dele"));
        assertEquals("delete", getCommand("detele"));

    }

    @Test
    public void levenshteinDistance() throws Exception {
        //addition
        assertEquals((Integer) 1, getLevenshteinDistance("ad", "add"));
        assertEquals((Integer) 2, getLevenshteinDistance("dele", "delete"));
        //substitution
        assertEquals((Integer) 2, getLevenshteinDistance("lsit", "list"));
        assertEquals((Integer) 3, getLevenshteinDistance("letede", "delete"));
        //subtraction
        assertEquals((Integer) 1, getLevenshteinDistance("liste", "list"));
        assertEquals((Integer) 2, getLevenshteinDistance("deletete", "delete"));
        //mixed: 1 sub + 1 subtraction
        assertEquals((Integer) 3, getLevenshteinDistance("lsite", "list"));
    }

    /**
     * Return result from getClosestCommand in languageUtil
     * @param cmd commandWord
     * @return nearest commandword
     */
    private String getCommand(String cmd) {
        return LanguageUtil.getClosestCommand(cmd);
    }

    /**
     * Return Levenshtein distance between 2 strings
     * @param s1 first string
     * @param s2 second string
     * @return levenshtein distance
     */
    private Integer getLevenshteinDistance(String s1, String s2) {
        return LanguageUtil.levenshteinDistance(s1, s1.length(), s2, s2.length());
    }

}
```
###### /java/seedu/address/model/person/FavoriteTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class FavoriteTest {

    @Test
    public void testEquals() {
        // equal Favorite objects
        assertTrue(new Favorite(true).equals(new Favorite(true)));
        assertTrue(new Favorite(false).equals(new Favorite(false)));

        //unequal Favorite objects
        assertFalse(new Favorite(true).equals(new Favorite(false)));
        assertFalse(new Favorite(false).equals(new Favorite(true)));
    }
}
```
###### /java/seedu/address/model/person/PersonTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import static seedu.address.logic.commands.CommandTestUtil.VALID_ADDRESS_AMY;
import static seedu.address.logic.commands.CommandTestUtil.VALID_EMAIL_AMY;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NAME_AMY;
import static seedu.address.logic.commands.CommandTestUtil.VALID_PHONE_AMY;
import static seedu.address.testutil.TypicalPersons.AMY;

import java.util.Collections;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;

public class PersonTest {
    public static final UniqueTagList TAG_LIST = new UniqueTagList();
    private Person person = new Person(AMY);

    @Test(expected = IllegalValueException.class)
    public void setName() throws Exception {
        person.setName(new Name("Akatsuki_wtf@12"));
    }

    @Test
    public void nameProperty() throws Exception {
        assertEquals(person.nameProperty().get(), new Name(VALID_NAME_AMY));
    }

    @Test
    public void getName() throws Exception {
        assertEquals(person.getName(), new Name(VALID_NAME_AMY));
    }

    @Test(expected = IllegalValueException.class)
    public void setPhone() throws Exception {
        person.setPhone(new Phone("asd1213f_2"));
    }

    @Test
    public void phoneProperty() throws Exception {
        assertEquals(person.phoneProperty().get(), new Phone(VALID_PHONE_AMY));
    }

    @Test
    public void getPhone() throws Exception {
        assertEquals(person.getPhone(), new Phone(VALID_PHONE_AMY));
    }

    @Test(expected = IllegalValueException.class)
    public void setEmail() throws Exception {
        person.setEmail(new Email("notValidEmail"));
    }

    @Test
    public void emailProperty() throws Exception {
        assertEquals(person.emailProperty().get(), new Email(VALID_EMAIL_AMY));
    }

    @Test
    public void getEmail() throws Exception {
        assertEquals(person.getEmail(), new Email(VALID_EMAIL_AMY));
    }

    @Test(expected = NullPointerException.class)
    public void setAddress() throws Exception {
        person.setAddress(null);
    }

    @Test
    public void addressProperty() throws Exception {
        assertEquals(person.addressProperty().get(), new Address(VALID_ADDRESS_AMY));
    }

    @Test
    public void getAddress() throws Exception {
        assertEquals(person.getAddress(), new Address(VALID_ADDRESS_AMY));
    }

    @Test(expected = NullPointerException.class)
    public void setRemark() throws Exception {
        person.setRemark(null);
    }

    @Test
    public void remarkProperty() throws Exception {
        assertEquals(person.remarkProperty().get(), new Remark(""));
    }

    @Test
    public void getRemark() throws Exception {
        assertEquals(person.getRemark(), new Remark(""));
    }

    @Test(expected = NullPointerException.class)
    public void setFavorite() throws Exception {
        person.setFavorite(null);
    }

    @Test
    public void favoriteProperty() throws Exception {
        assertEquals(person.favoriteProperty().get(), new Favorite());
    }

    @Test
    public void getFavorite() throws Exception {
        assertEquals(person.getFavorite(), new Favorite());
    }

    @Test
    public void getTags() throws Exception {
        TAG_LIST.add(new Tag("friend"));
        assertEquals(person.getTags(), TAG_LIST.toSet());
    }

    @Test
    public void getTagsString() throws Exception {
        assertEquals(person.getTagsString(), Collections.singletonList("friend"));
    }

    @Test
    public void tagProperty() throws Exception {
        assertEquals(person.tagProperty().get(), TAG_LIST);
    }

    @Test(expected = NullPointerException.class)
    public void setTags() throws Exception {
        person.setTags(null);
    }

    @Test
    public void equals() throws Exception {
        assertTrue(person.equals(person));
    }

}
```
###### /java/seedu/address/model/person/predicates/AddressContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.person.predicates;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.PersonBuilder;

public class AddressContainsKeywordsPredicateTest {
    @Test
    public void test_addressContainsKeywords_returnsTrue() {
        // One keyword
        AddressContainsKeywordsPredicate predicate = new AddressContainsKeywordsPredicate(
                Arrays.asList("Prince", "George", "Park"));
        assertTrue(predicate.test(new PersonBuilder().withAddress("Prince George Park").build()));

        // Multiple keywords
        predicate = new AddressContainsKeywordsPredicate(Arrays.asList("Prince", "George", "Park", "NUS"));
        assertTrue(predicate.test(new PersonBuilder().withAddress("Prince George Park").build()));

        // Only one matching keyword
        predicate = new AddressContainsKeywordsPredicate(Arrays.asList("Prince", "George", "Park", "NUS"));
        assertTrue(predicate.test(new PersonBuilder().withAddress("NUSU").build()));

        // Mixed-case keywords
        predicate = new AddressContainsKeywordsPredicate(Arrays.asList("Prince", "George", "Park", "NUS"));
        assertTrue(predicate.test(new PersonBuilder().withAddress("NUS").build()));
    }

    @Test
    public void test_addressDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        AddressContainsKeywordsPredicate predicate = new AddressContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new PersonBuilder().withAddress("NUS").build()));

        // Non-matching keyword
        predicate = new AddressContainsKeywordsPredicate(Arrays.asList("Prince", "George", "Park", "NUS"));
        assertFalse(predicate.test(new PersonBuilder().withName("NUS").build()));

        // Keywords match name, email and birthday, but does not match address
        predicate = new AddressContainsKeywordsPredicate(
                Arrays.asList("Alice", "alice@email.com", "Main", "01/01/1990"));
        assertFalse(predicate.test(new PersonBuilder().withName("Alice").withPhone("12345")
                .withEmail("alice@email.com").withAddress("Street").withBirthday("01/01/1990").build()));
    }

    @Test
    public void equals() throws Exception {
        List<String> firstPredicateKeywordList = Collections.singletonList("first");
        List<String> secondPredicateKeywordList = Arrays.asList("first", "second");

        AddressContainsKeywordsPredicate firstPredicate =
                new AddressContainsKeywordsPredicate(firstPredicateKeywordList);
        AddressContainsKeywordsPredicate secondPredicate =
                new AddressContainsKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        AddressContainsKeywordsPredicate firstPredicateCopy =
                new AddressContainsKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different person -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

}
```
###### /java/seedu/address/model/person/predicates/AnyContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.person.predicates;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.testutil.PersonBuilder;

public class AnyContainsKeywordsPredicateTest {
    private static Set<Tag> set1 = new UniqueTagList().toSet();
    private static Set<Tag> set2 = new UniqueTagList().toSet();
    private static AnyContainsKeywordsPredicate predicate1 = new AnyContainsKeywordsPredicate(
            Arrays.asList("Alice", "street"));
    private static AnyContainsKeywordsPredicate predicate2 = new AnyContainsKeywordsPredicate(
            Collections.singletonList("gmail.com"));


    @Before
    public void setUp() throws Exception {
        set1.add(new Tag("friends"));
        set1.add(new Tag("family"));
        set2.add(new Tag("friends"));

    }

    @Test
    public void test_anyContainsKeywords_returnsTrue() {
        // One keyword
        assertTrue(predicate2.test(new PersonBuilder().withEmail("huehue@gmail.com").build()));

        // Multiple keywords
        assertTrue(predicate1.test(new PersonBuilder().withName("Alice").build()));

        // Only one matching sub-keyword
        assertTrue(predicate1.test(new PersonBuilder().withName("Alicey").build()));
    }

    @Test
    public void test_anyDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        AnyContainsKeywordsPredicate predicate0 = new AnyContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate0.test(new PersonBuilder().withTags("cs2103").build()));

        // Non-matching keyword
        assertFalse(predicate2.test(new PersonBuilder().withEmail("haha@yahoo.com").build()));

        assertFalse(predicate1.test(new PersonBuilder().withName("Alic").withPhone("12345")
                .withEmail("alic@email.com").withAddress("Stree").withBirthday("01/01/1990")
                .withTags("cs2103").build()));
    }

    @Test
    public void equals() throws Exception {

        // same object -> returns true
        assertTrue(predicate1.equals(predicate1));

        // same values -> returns true
        AnyContainsKeywordsPredicate firstPredicateCopy = new AnyContainsKeywordsPredicate(
                Arrays.asList("Alice", "street"));
        assertTrue(predicate1.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(predicate1.equals(1));

        // null -> returns false
        assertFalse(predicate1.equals(null));

        // different person -> returns false
        assertFalse(predicate1.equals(predicate2));
    }

}
```
###### /java/seedu/address/model/person/predicates/EmailContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.person.predicates;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.PersonBuilder;

public class EmailContainsKeywordsPredicateTest {
    @Test
    public void test_emailContainsKeywords_returnsTrue() {
        // One keyword
        EmailContainsKeywordsPredicate predicate = new EmailContainsKeywordsPredicate(
                Collections.singletonList("example@mail.com"));
        assertTrue(predicate.test(new PersonBuilder().withEmail("example@mail.com").build()));

        // Multiple keywords
        predicate = new EmailContainsKeywordsPredicate(Arrays.asList("example@mail.com", "example@yeahoo.com"));
        assertTrue(predicate.test(new PersonBuilder().withEmail("example@mail.com").build()));

        // Only one matching sub-keyword
        predicate = new EmailContainsKeywordsPredicate(Arrays.asList("example@mail.com", "example@yeahoo.com"));
        assertTrue(predicate.test(new PersonBuilder().withEmail("example@mail.com.sg").build()));

        // Mixed-case keywords
        predicate = new EmailContainsKeywordsPredicate(Arrays.asList("example@MAIl.com", "example@yeahoo.com"));
        assertTrue(predicate.test(new PersonBuilder().withEmail("example@mail.com").build()));
    }

    @Test
    public void test_emailDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        EmailContainsKeywordsPredicate predicate = new EmailContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new PersonBuilder().withEmail("example@mail.com").build()));

        // Non-matching keyword
        predicate = new EmailContainsKeywordsPredicate(Arrays.asList("example@mail.com", "example@yahoo.com"));
        assertFalse(predicate.test(new PersonBuilder().withEmail("example@facebook.com").build()));

        // Keywords match name, address and birthday, but does not match email
        predicate = new EmailContainsKeywordsPredicate(
                Arrays.asList("Ben", "Street", "Main", "01/01/1990"));
        assertFalse(predicate.test(new PersonBuilder().withName("Alice").withPhone("12345")
                .withEmail("alice@email.com").withAddress("Street").withBirthday("01/01/1990").build()));
    }

    @Test
    public void equals() throws Exception {
        List<String> firstPredicateKeywordList = Collections.singletonList("example@mail.com");
        List<String> secondPredicateKeywordList = Arrays.asList("example@mail.com", "example@yahoo.com");

        EmailContainsKeywordsPredicate firstPredicate = new EmailContainsKeywordsPredicate(firstPredicateKeywordList);
        EmailContainsKeywordsPredicate secondPredicate = new EmailContainsKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        EmailContainsKeywordsPredicate firstPredicateCopy =
                new EmailContainsKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different person -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

}
```
###### /java/seedu/address/model/person/predicates/PhoneContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.person.predicates;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.Test;

import seedu.address.testutil.PersonBuilder;

public class PhoneContainsKeywordsPredicateTest {
    @Test
    public void test_phoneContainsKeywords_returnsTrue() {
        // One keyword
        PhoneContainsKeywordsPredicate predicate = new PhoneContainsKeywordsPredicate(
                Collections.singletonList("84041421"));
        assertTrue(predicate.test(new PersonBuilder().withPhone("84041421").build()));

        // Multiple keywords
        predicate = new PhoneContainsKeywordsPredicate(Arrays.asList("84041421", "84041415"));
        assertTrue(predicate.test(new PersonBuilder().withPhone("84041421").build()));

        // Only one matching sub-keyword
        predicate = new PhoneContainsKeywordsPredicate(Arrays.asList("84041421", "840414"));
        assertTrue(predicate.test(new PersonBuilder().withPhone("8404142").build()));
    }

    @Test
    public void test_phoneDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        PhoneContainsKeywordsPredicate predicate = new PhoneContainsKeywordsPredicate(Collections.emptyList());
        assertFalse(predicate.test(new PersonBuilder().withPhone("84041421").build()));

        // Non-matching keyword
        predicate = new PhoneContainsKeywordsPredicate(Arrays.asList("84041421", "84041415"));
        assertFalse(predicate.test(new PersonBuilder().withPhone("84041499").build()));

        // Keywords match name, address, email and birthday, but does not match phone
        predicate = new PhoneContainsKeywordsPredicate(
                Arrays.asList("Ben", "Street", "Main", "01/01/1990"));
        assertFalse(predicate.test(new PersonBuilder().withName("Alice").withPhone("12345")
                .withEmail("alice@email.com").withAddress("Street").withBirthday("01/01/1990").build()));
    }

    @Test
    public void equals() throws Exception {
        List<String> firstPredicateKeywordList = Collections.singletonList("84041421");
        List<String> secondPredicateKeywordList = Arrays.asList("84041421", "84041415");

        PhoneContainsKeywordsPredicate firstPredicate = new PhoneContainsKeywordsPredicate(firstPredicateKeywordList);
        PhoneContainsKeywordsPredicate secondPredicate = new PhoneContainsKeywordsPredicate(secondPredicateKeywordList);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        PhoneContainsKeywordsPredicate firstPredicateCopy =
                new PhoneContainsKeywordsPredicate(firstPredicateKeywordList);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different person -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

}
```
###### /java/seedu/address/model/person/predicates/TagContainsKeywordsPredicateTest.java
``` java
package seedu.address.model.person.predicates;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.testutil.PersonBuilder;

public class TagContainsKeywordsPredicateTest {
    private static Set<Tag> set1 = new UniqueTagList().toSet();
    private static Set<Tag> set2 = new UniqueTagList().toSet();

    @Before
    public void setUp() throws Exception {
        set1.add(new Tag("friends"));
        set1.add(new Tag("family"));
        set2.add(new Tag("friends"));

    }
    @Test
    public void test_tagContainsKeywords_returnsTrue() {
        // One keyword
        TagContainsKeywordsPredicate predicate = new TagContainsKeywordsPredicate(set2);
        assertTrue(predicate.test(new PersonBuilder().withTags("friends").build()));

        // Multiple keywords
        predicate = new TagContainsKeywordsPredicate(set1);
        assertTrue(predicate.test(new PersonBuilder().withTags("friends").build()));

        // Only one matching sub-keyword
        predicate = new TagContainsKeywordsPredicate(set1);
        assertTrue(predicate.test(new PersonBuilder().withTags("friendship").build()));
    }

    @Test
    public void test_tagDoesNotContainKeywords_returnsFalse() {
        // Zero keywords
        TagContainsKeywordsPredicate predicate = new TagContainsKeywordsPredicate(new UniqueTagList().toSet());
        assertFalse(predicate.test(new PersonBuilder().withTags("cs2103").build()));

        // Non-matching keyword
        predicate = new TagContainsKeywordsPredicate(set1);
        assertFalse(predicate.test(new PersonBuilder().withTags("cs2103").build()));

        predicate = new TagContainsKeywordsPredicate(set1);
        assertFalse(predicate.test(new PersonBuilder().withName("Alice").withPhone("12345")
                .withEmail("alice@email.com").withAddress("Street").withBirthday("01/01/1990")
                .withTags("cs2103").build()));
    }

    @Test
    public void equals() throws Exception {
        TagContainsKeywordsPredicate firstPredicate = new TagContainsKeywordsPredicate(set1);
        TagContainsKeywordsPredicate secondPredicate = new TagContainsKeywordsPredicate(set2);

        // same object -> returns true
        assertTrue(firstPredicate.equals(firstPredicate));

        // same values -> returns true
        TagContainsKeywordsPredicate firstPredicateCopy = new TagContainsKeywordsPredicate(set1);
        assertTrue(firstPredicate.equals(firstPredicateCopy));

        // different types -> returns false
        assertFalse(firstPredicate.equals(1));

        // null -> returns false
        assertFalse(firstPredicate.equals(null));

        // different person -> returns false
        assertFalse(firstPredicate.equals(secondPredicate));
    }

}
```
###### /java/systemtests/FavoriteCommandSystemTest.java
``` java
package systemtests;

import static org.junit.Assert.assertTrue;
import static seedu.address.model.Model.PREDICATE_SHOW_ALL_PERSONS;
import static seedu.address.testutil.TestUtil.getLastIndex;
import static seedu.address.testutil.TestUtil.getMidIndex;
import static seedu.address.testutil.TestUtil.getPerson;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST_PERSON;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND_PERSON;
import static seedu.address.testutil.TypicalPersons.KEYWORD_MATCHING_MEIER;

import java.util.Collections;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.FavoriteCommand;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.model.Model;
import seedu.address.model.person.Favorite;
import seedu.address.model.person.Person;
import seedu.address.model.person.ReadOnlyPerson;
import seedu.address.model.person.exceptions.PersonNotFoundException;
import seedu.address.model.person.predicates.NameContainsKeywordsPredicate;


public class FavoriteCommandSystemTest extends AddressBookSystemTest {

    // this message is used to match message in result display, which should be empty for any failed execution
    private static final String MESSAGE_EXECUTION_FAILURE_EMPTY = "";

    private static final String MESSAGE_INVALID_FAVORITE_COMMAND_FORMAT =
            String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, FavoriteCommand.MESSAGE_USAGE);

    @Test
    public void favorite() {
        /* ----------- Performing favorite operation while an unfiltered list is being shown -------------------- */

        /* Case: favorite the first person in the list, command with leading spaces and trailing spaces -> favorited */
        Model expectedModel = getModel();
        String command = FavoriteCommand.COMMAND_WORD
                + " " + INDEX_FIRST_PERSON.getOneBased() + "       ";
        ReadOnlyPerson personToFavorite = favoritePerson(expectedModel, INDEX_FIRST_PERSON);

        String expectedResultMessage = String.format(
                FavoriteCommand.MESSAGE_FAVORITE_PERSON_SUCCESS, personToFavorite);
        assertCommandSuccess(command, expectedModel, expectedResultMessage);


        /* Case: favorite the last person in the list -> favorited */
        Model modelBeforeFavoritingLast = getModel();
        Index lastPersonIndex = getLastIndex(modelBeforeFavoritingLast);
        assertCommandSuccess(lastPersonIndex);

        /* Case: undo favoriting the last person in the list -> last person restored */
        command = UndoCommand.COMMAND_WORD;
        expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeFavoritingLast, expectedResultMessage);

        /* Case: redo favoriting the last person in the list -> last person deleted again */
        command = RedoCommand.COMMAND_WORD;
        favoritePerson(modelBeforeFavoritingLast, lastPersonIndex);
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeFavoritingLast, expectedResultMessage);

        /* Case: favorite the middle person in the list -> deleted */
        Index middlePersonIndex = getMidIndex(getModel());
        assertCommandSuccess(middlePersonIndex);

        /* ----------- Performing favorite operation while a filtered list is being shown ------------------- */

        /* Case: filtered person list, favorite index within bounds of address book and person list -> favorited */
        showPersonsWithName(KEYWORD_MATCHING_MEIER);
        Index index = INDEX_FIRST_PERSON;
        assertTrue(index.getZeroBased() < getModel().getFilteredPersonList().size());
        assertCommandSuccess(index, INDEX_SECOND_PERSON);

        /* Case: filtered person list, favorite index within bounds of address book but out of bounds of person list
         * -> rejected
         */
        showPersonsWithName(KEYWORD_MATCHING_MEIER);
        int invalidIndex = getModel().getAddressBook().getPersonList().size();
        command = FavoriteCommand.COMMAND_WORD + " " + invalidIndex;
        assertCommandFailure(command, MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* --------------- Performing favorite operation while a person card is selected ------------------- */

        /* Case: favorite the selected person -> person list panel selects the same person*/
        showAllPersons();
        expectedModel = getModel();
        Index selectedIndex = getLastIndex(expectedModel);
        Index expectedIndex = INDEX_SECOND_PERSON;
        selectPerson(selectedIndex);
        command = FavoriteCommand.COMMAND_WORD + " " + selectedIndex.getOneBased();
        personToFavorite = favoritePerson(expectedModel, selectedIndex);

        expectedResultMessage = String.format(FavoriteCommand.MESSAGE_FAVORITE_PERSON_SUCCESS, personToFavorite);
        assertCommandSuccess(command, expectedModel, expectedResultMessage, expectedIndex);

        /* --------------------------- Performing invalid favorite operation ---------------------------- */

        /* Case: invalid index (0) -> rejected */
        command = FavoriteCommand.COMMAND_WORD + " 0";
        assertCommandFailure(command, MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: invalid index (-1) -> rejected */
        command = FavoriteCommand.COMMAND_WORD + " -1";
        assertCommandFailure(command, MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: invalid index (size + 1) -> rejected */
        Index outOfBoundsIndex = Index.fromOneBased(
                getModel().getAddressBook().getPersonList().size() + 1);
        command = FavoriteCommand.COMMAND_WORD + " " + outOfBoundsIndex.getOneBased();
        assertCommandFailure(command, MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: invalid arguments (alphabets) -> rejected */
        assertCommandFailure(FavoriteCommand.COMMAND_WORD + " abc", MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: invalid arguments (extra argument) -> rejected */
        assertCommandFailure(FavoriteCommand.COMMAND_WORD + " 1 abc", MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: mixed case command word -> rejected */
        assertCommandFailure("FaVORIte 1",
                MESSAGE_EXECUTION_FAILURE_EMPTY);
    }

    /**
     * Removes the {@code ReadOnlyPerson} at the specified {@code index} in {@code model}'s address book.
     * @return the favorited person
     */
    private ReadOnlyPerson favoritePerson(Model model, Index index) {
        ReadOnlyPerson targetPerson = getPerson(model, index);
        try {
            model.favoritePerson(targetPerson);
            model.updateFilteredPersonList(PREDICATE_SHOW_ALL_PERSONS);
        } catch (PersonNotFoundException pnfe) {
            throw new AssertionError("targetPerson is retrieved from model.");
        }
        Person favoritedPerson = new Person(targetPerson);
        favoritedPerson.setFavorite(
                new Favorite(!targetPerson.getFavorite().favorite));
        return favoritedPerson;
    }

    /**
     * Favorite the person at {@code toFavorite} by creating a default {@code FavoriteCommand} using
     * {@code toFavorite} and performs the same verification as {@code assertCommandSuccess(String, Model, String)}.
     * @see FavoriteCommandSystemTest#assertCommandSuccess(String, Model, String)
     */
    private void assertCommandSuccess(Index toFavorite) {
        Model expectedModel = getModel();
        ReadOnlyPerson personToFavorite = favoritePerson(expectedModel, toFavorite);
        String expectedResultMessage = String.format(FavoriteCommand.MESSAGE_FAVORITE_PERSON_SUCCESS, personToFavorite);
        assertCommandSuccess(
                FavoriteCommand.COMMAND_WORD + " "
                        + toFavorite.getOneBased(), expectedModel, expectedResultMessage);
    }

    /**
     * Favorite the person at {@code toFavorite} in a filtered list which is equivalent to a person at
     * {@code defaultIndex} in the normal Model, by creating a default {@code FavoriteCommand} using {@code toFavorite}
     * and performs the same verification as {@code assertCommandSuccess(String, Model, String)}.
     * @see FavoriteCommandSystemTest#assertCommandSuccess(String, Model, String)
     */
    private void assertCommandSuccess(Index toFavorite, Index defaultIndex) {
        Model expectedModel = getModel();

        ReadOnlyPerson personToFavorite = favoritePerson(expectedModel, defaultIndex);
        String expectedResultMessage = String.format(FavoriteCommand.MESSAGE_FAVORITE_PERSON_SUCCESS, personToFavorite);
        expectedModel.updateFilteredPersonList(
                new NameContainsKeywordsPredicate(Collections.singletonList(KEYWORD_MATCHING_MEIER)));
        assertCommandSuccess(
                FavoriteCommand.COMMAND_WORD + " "
                        + toFavorite.getOneBased(), expectedModel, expectedResultMessage);
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays an empty string.<br>
     * 2. Asserts that the result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to {@code expectedModel}.<br>
     * 4. Asserts that the browser url and selected card remains unchanged.<br>
     * 5. Asserts that the status bar's sync status changes.<br>
     * 6. Asserts that the command box has the default style class.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        assertCommandSuccess(command, expectedModel, expectedResultMessage, null);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Model, String)} except that the browser url
     * and selected card are expected to update accordingly depending on the card at {@code expectedSelectedCardIndex}.
     * @see FavoriteCommandSystemTest#assertCommandSuccess(String, Model, String)
     * @see AddressBookSystemTest#assertSelectedCardChanged(Index)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage,
                                      Index expectedSelectedCardIndex) {
        executeCommand(command, false);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);

        if (expectedSelectedCardIndex != null) {
            assertSelectedCardChanged(expectedSelectedCardIndex);
        } else {
            assertSelectedCardUnchanged();
        }

        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchangedExceptSyncStatus();
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays {@code command}.<br>
     * 2. Asserts that result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to the current model.<br>
     * 4. Asserts that the browser url, selected card and status bar remain unchanged.<br>
     * 5. Asserts that the command box has the error style.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command, true);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
###### /java/systemtests/RemarkCommandSystemTest.java
``` java
package systemtests;

import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.NAME_DESC_BOB;
import static seedu.address.logic.commands.CommandTestUtil.REMARK_DESC_ANY;
import static seedu.address.logic.commands.CommandTestUtil.VALID_REMARK;
import static seedu.address.model.Model.PREDICATE_SHOW_ALL_PERSONS;
import static seedu.address.testutil.TestUtil.getPerson;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST_PERSON;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND_PERSON;
import static seedu.address.testutil.TypicalPersons.ALICE;
import static seedu.address.testutil.TypicalPersons.BENSON;
import static seedu.address.testutil.TypicalPersons.KEYWORD_MATCHING_MEIER;

import org.junit.Test;

import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.RemarkCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.model.Model;
import seedu.address.model.person.Person;
import seedu.address.model.person.ReadOnlyPerson;
import seedu.address.model.person.Remark;
import seedu.address.model.person.exceptions.DuplicatePersonException;
import seedu.address.model.person.exceptions.PersonNotFoundException;
import seedu.address.testutil.PersonBuilder;

public class RemarkCommandSystemTest extends AddressBookSystemTest {

    // this message is used to match message in result display, which should be empty for any failed execution
    private static final String MESSAGE_EXECUTION_FAILURE_EMPTY = "";

    @Test
    public void remark() throws Exception {
        Model model = getModel();

        /* -------------- Performing remark operation while an unfiltered list is being shown -------------------- */

        /* Case: remark a valid index in the list -> edited
         */
        Model expectedModel = getModel();
        Index index = INDEX_FIRST_PERSON;
        String command = " " + RemarkCommand.COMMAND_WORD + "  " + index.getOneBased() + "  " + REMARK_DESC_ANY;

        ReadOnlyPerson personToEdit = getPerson(expectedModel, index);
        Person newPerson = RemarkCommand.addOrChangeRemark(
                personToEdit, new Remark(VALID_REMARK));
        assertCommandSuccess(command, index, newPerson);

        /* Case: undo remarking the last person in the list -> last person restored */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: redo remarking the last person in the list -> last person edited again */
        command = RedoCommand.COMMAND_WORD;
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        model.updatePerson(
                getModel().getFilteredPersonList().get(INDEX_FIRST_PERSON.getZeroBased()), newPerson);
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: remark a person with new values same as existing values -> remark */
        command = RemarkCommand.COMMAND_WORD + " " + INDEX_SECOND_PERSON.getOneBased()
                + " ";
        assertCommandSuccess(command, INDEX_SECOND_PERSON, BENSON);



        /* ------------------ Performing edit operation while a filtered list is being shown ------------------------ */

        /* Case: filtered person list, edit index within bounds of address book and person list -> edited */
        showPersonsWithName(KEYWORD_MATCHING_MEIER);
        index = INDEX_FIRST_PERSON;
        assertTrue(index.getZeroBased() < getModel().getFilteredPersonList().size());
        command = RemarkCommand.COMMAND_WORD + " " + index.getOneBased() + " " + REMARK_DESC_ANY;
        personToEdit = getModel().getFilteredPersonList().get(index.getZeroBased());
        newPerson = new PersonBuilder(personToEdit).withRemark(VALID_REMARK).build();
        assertCommandSuccess(command, index, newPerson);

        /* Case: filtered person list, edit index within bounds of address book but out of bounds of person list
         * -> rejected
         */
        showPersonsWithName(KEYWORD_MATCHING_MEIER);
        int invalidIndex = getModel().getAddressBook().getPersonList().size();
        assertCommandFailure(RemarkCommand.COMMAND_WORD + " " + invalidIndex + REMARK_DESC_ANY,
                MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* ---------------------Performing remark operation while a person card is selected ------------------------- */

        /* Case: selects first card in the person list, remark a person -> remarked, card selection
         * remains unchanged but browser url changes
         */
        showAllPersons();
        index = INDEX_FIRST_PERSON;
        selectPerson(index);
        command = RemarkCommand.COMMAND_WORD + " "
                + index.getOneBased() + REMARK_DESC_ANY;
        // this can be misleading: card selection actually remains unchanged but the
        // browser's url is updated to reflect the new person's name
        newPerson = new Person(ALICE);
        newPerson.setRemark(new Remark("dev"));
        assertCommandSuccess(command, index, newPerson, index);

        /* -------------------------------- Performing invalid remark operation ------------------------------------ */

        /* Case: invalid index (0) -> rejected */
        assertCommandFailure(RemarkCommand.COMMAND_WORD + " 0" + NAME_DESC_BOB,
                MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: invalid index (-1) -> rejected */
        assertCommandFailure(RemarkCommand.COMMAND_WORD + " -1" + NAME_DESC_BOB,
                MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: invalid index (size + 1) -> rejected */
        invalidIndex = getModel().getFilteredPersonList().size() + 1;
        assertCommandFailure(RemarkCommand.COMMAND_WORD + " " + invalidIndex + REMARK_DESC_ANY,
                MESSAGE_EXECUTION_FAILURE_EMPTY);

        /* Case: missing index -> rejected */
        assertCommandFailure(RemarkCommand.COMMAND_WORD + NAME_DESC_BOB,
                MESSAGE_EXECUTION_FAILURE_EMPTY);

    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Index, ReadOnlyPerson, Index)} except that
     * the browser url and selected card remain unchanged.
     * @param toRemark the index of the current model's filtered list
     * @see RemarkCommandSystemTest#assertCommandSuccess(String, Index, ReadOnlyPerson, Index)
     */
    private void assertCommandSuccess(String command, Index toRemark, ReadOnlyPerson editedPerson) {
        assertCommandSuccess(command, toRemark, editedPerson, null);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Model, String, Index)} and in addition,<br>
     * 1. Asserts that result display box displays the success message of executing {@code EditCommand}.<br>
     * 2. Asserts that the model related components are updated to reflect the person at index {@code toEdit} being
     * updated to values specified {@code editedPerson}.<br>
     * @param toRemark the index of the current model's filtered list.
     * @see RemarkCommandSystemTest#assertCommandSuccess(String, Model, String, Index)
     */
    private void assertCommandSuccess(String command, Index toRemark, ReadOnlyPerson editedPerson,
                                      Index expectedSelectedCardIndex) {
        Model expectedModel = getModel();
        try {
            expectedModel.updatePerson(
                    expectedModel.getFilteredPersonList().get(toRemark.getZeroBased()), editedPerson);
            expectedModel.updateFilteredPersonList(PREDICATE_SHOW_ALL_PERSONS);
        } catch (DuplicatePersonException | PersonNotFoundException e) {
            throw new IllegalArgumentException(
                    "editedPerson is a duplicate in expectedModel, or it isn't found in the model.");
        }

        assertCommandSuccess(command, expectedModel,
                String.format(RemarkCommand.MESSAGE_REMARK_PERSON_SUCCESS, editedPerson), expectedSelectedCardIndex);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Model, String, Index)} except that the
     * browser url and selected card remain unchanged.
     * @see RemarkCommandSystemTest#assertCommandSuccess(String, Model, String, Index)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        assertCommandSuccess(command, expectedModel, expectedResultMessage, null);
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays an empty string.<br>
     * 2. Asserts that the result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to {@code expectedModel}.<br>
     * 4. Asserts that the browser url and selected card update accordingly depending on the card at
     * {@code expectedSelectedCardIndex}.<br>
     * 5. Asserts that the status bar's sync status changes.<br>
     * 6. Asserts that the command box has the default style class.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     * @see AddressBookSystemTest#assertSelectedCardChanged(Index)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage,
                                      Index expectedSelectedCardIndex) {
        executeCommand(command, false);
        expectedModel.updateFilteredPersonList(PREDICATE_SHOW_ALL_PERSONS);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertCommandBoxShowsDefaultStyle();
        if (expectedSelectedCardIndex != null) {
            assertSelectedCardChanged(expectedSelectedCardIndex);
        } else {
            assertSelectedCardUnchanged();
        }
        assertStatusBarUnchangedExceptSyncStatus();
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays {@code command}.<br>
     * 2. Asserts that result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to the current model.<br>
     * 4. Asserts that the browser url, selected card and status bar remain unchanged.<br>
     * 5. Asserts that the command box has the error style.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     *
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command, true);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
